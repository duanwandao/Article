# 面向对象编程OOP（Object Oriented Programming）

+ 面向对象是把事务分解成为一个对象，然后由对象之间分工合作  

## 1.对象  

+ 封装性
+ 继承性
+ 多态性

### 面向过程和面向对象的对比  

#### 面向过程

+ 优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程  
+ 缺点：没有面向对象易维护、易复用、易扩展  

#### 面向对象  

+ 优点：易维护、易复用、易扩展。由于面向对象有封装、继承、多态性的特点，可以设计出低耦合的系统，使系统更加灵活更加容易维护  
+ 缺点：性能比面向过程低  

### 面向对象的思维特点  

1. 抽取（抽象）对象共用的属性和行为组织（封装）称为一个类（模板）  
2. 对类进行实例化，获取类的对象  

### 对象解释  

> 现实生活中，万物皆对象，对象是一个具体的事物，看得见摸得着的实物。例如：一本书、一辆汽车、一个人可以使对象，一个数据库，一张网页，一个与远程服务器的连接也可以是对象  
> 在JavaScript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。  
> 对象是由属性和方法组成的：
> > 属性：事物的特征，在对象中庸属性来表示（常用名词）  
> > 方法：事物的行为，在对象中用方法来表示（常用动词）  

## 2.类 class

> 在es6中新增加了类的概念，可以使用class关键字声明一个类，之后以这个类来实例化对象  
> 类抽象了对象的公共部分，它泛指某一个大类  
> 对象特指某一个，通过类实例化一个具体的对象  

![类与对象的对比](https://www.kanjiantu.com/images/2019/09/06/S23M98E1BQK3Y3ZF3D187d2df16d741865.png "类与对象")  

### 创建类  

语法：

```javascript
class name {
  //class body
}
//创建实例：
var xx = new name();
//注意 类必须使用new实例化对象
```  

### 类 constructor 构造函数  

> constructor()方法时类的构造函数（默认方法）用于传递参数，返回实例对象，通过new命令生成对象实例时，自动调用该方法，如果没有显示定义，类内部会自动给我们创建一个constructor（）  

```javascript
class Name{
  constructor(uname){
    this.uname=uname;
  }
}
var liudehua = new Name('刘德华');
console.log(liudehua.uname);//'刘德华'
//类中添加方法
class Name{
  constructor(uname){
    this.uname=uname;
  }
  sing(){
    console.logh('唱歌')
  }
}
```  

1. 通过class关键字创建类，类名我们还是习惯性定义首字母大写  
2. 类里面有个constructor函数，可以接受传递过来的参数，同时返回实例对象
3. constructor函数只要new生成实例时，就会自动调用这个函数，如果我们不写这个函数，类也会自动生成这个函数  
4. 生成实例new不能省略  
5. 最后注意语法规范，创建类 类名后面不要加小括号，构造函数不需要加function  
6. 我们类里面的所有的函数不需要写function
7. 多个函数方法之间不需要添加逗号分隔

## 3.类的继承  

### 继承  

> 现实中的继承，子承父业，比如我们都继承了父亲的姓  
> 程序中的继承：子类可以继承父类的一些属性和方法  

```javascript
//语法：
class Father{
  //父类
}
class Son extends Father{
  //子类继承父类
}
```  

### super关键字  

```javascript

class Father{
  //父类
  constructor(x,y){
    this.x=x;
    this.y=y;
  }
  sun(){
    console.log(this.x+this.y)
  }
}
class Son extends Father{
  //子类继承父类
  constructor(x,y){
    super(x,y)//调用了父类中的构造函数
  }
}
//在继承中，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就先执行子类的
//继承中，如果子类里面没有方法，就去查找父类有没有这个方法，如果有，就执行父类的这个方法（就近原则）

//子类继承父类的加法方法，同时扩展减法方法
//注意：子类在构造函数中使用super 必须放到this前面（必须先调用父类的构造方法，再使用子类构造方法）
class Father{
  constructor(x,y){
    this.x=x;
    this.y=y;
  }
  sum(x,y){
    console.log(this.x+this.y);
  }
}

class Son extends Father{
  constructor(x,y){
    //利用super调用父类的构造函数
    //super必须在子类this之前调用
    super(x,y);
    this.x=x;
    this.y=y;
  }
  subtract(){
    .console.log(this.x-this.y);
  }
}
```  

### es6中类和对象注意点  

1. 在es6中类没有变量提升，所以必须先定义类，才能通过实例化对象  
2. 类里面的共有属性和方法一定要加this使用  
3. 类里面this的指向问题  
4. constructor里面的this指向实例对象，方法里卖弄的this指向这个方法的调用者  

## 4.构造函数和原型  

### 4.1概述  

> 在典型的OOP语言中都存在类的概念，类就是对象的模板，对象就是类的实例，但是在es6之前js中并没有类的概念  
> 在es6之前，对象不是基于类创建的，而是用一种称为构建函数的特殊函数来定义对象和他们的特征  

+ 创建对象可以通过以下三种方式：

  1. 对象字面量
  2. new Object（）
  3. 自定义构造函数  

### 4.2构造函数  

> 构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋值，他总与new一起使用，我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面  

+ 在js中，使用构造函数时候要注意一下两点：

  1. 构造函数函数用于创建某一类对象，其首字母要大写
  2. 构造函数要和new一起使用才有意义  

#### new在执行时候会做的四件事情

1. 在内存中创建一个新的空对象  
2. 让this指向这个新的对象
3. 执行构造函数里面的代码，给这个新对象添加属性和方法  
4. 返回这个新对象（所以构造函数里面不需要return）  

> js中的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的this上添加，通过这两种方法添加的成员，就分为静态成员和实例成员  

+ 静态成员：在构造函数本身上添加的成员称为静态成员，只能由构造函数本身来访问  
+ 实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问  

### 4.3构造函数原型prototype  

> 构造函数通过原型分配的函数是所有对象共享的  
> js规定，每一个函数都有一个prototype的属性，指向另一个对象，这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有  
> 我们可以把那些不变的方法，直接定义在prototype对象上，这样所有的对象的实例就可以共享这些方法。  

### 4.4对象原型__proto__  

> 对象都会有一个属性__proto__指向构造函数的prototype对象，之所以我们对象可以使用构造函数prototype原型对象的属性和方法，就是因为对象有__proto__原型的存在  

+ __proto__对象原型和原型对象prototype是等价的  
+ __proto__对象原型的意义就在于为对象的查找机制提供了一个方向，或者是一个路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象prototype  

## 4.5constructor 构造函数  

> 对象原型（__proto__）和构造函数（prototype）原型对象里面都有一个属性constructor属性，constructor我们称之为构造函数，因为它指回构造函数本身。  
> constructor主要用于记录该对象引用于那个构造函数，它可以让原型对象重新指向原来的构造函数  

### 4.6构造函数、实例、原型对象三者之间的关系  

![NI0H7HRPCP8H4B6U9f437df652f22517.png](https://www.kanjiantu.com/images/2019/09/08/NI0H7HRPCP8H4B6U9f437df652f22517.png)
