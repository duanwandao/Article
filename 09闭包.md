# 闭包作用域  
1. 创建函数  
	+ 开辟一个堆内存
	+ 把函数体中的代码当做字符串存储进去
	+ 把堆内存的地址赋值给函数名、变量名
	+ **函数在哪创建，那么它执行时候所需要查找的上级作用域就是谁**
2. 函数执行
	+ 形成一个全新的私有作用域、执行上下文、私有栈内存（执行一次形成一个，多个之间也不会产生影响）
	+ 形参赋值&变量提升
	+ 代码执行（把所属堆内存中的代码字符串拿出来一行一行的执行）
	+ **遇到一个变量，首先看他是不是私有变量（形参和在私有作用域中声明的变量是私有变量），是私有的就操作自己的变量即可，不是私有的则向上级作用域查找...一直找到全局作用域为止-->作用域链查找机制**
	+ 私有变量和外界的变量没有必然关系，可以理解为被栈内存保护起来了，这种机制其实就是闭包的保护机制
3. 关于堆栈内存释放问题
    > 函数执行就会形成栈内存（从内存中分配的一块空间）如果内存都不销毁释放，很容易就会导致栈内存溢出（内存爆满，电脑就会卡死），堆栈内存的释放问题是学习js的核心知识点
    + 堆内存释放问题
    ```javascript
    //创建一个引用类型值，就会产生一个堆内存
    //如果当前创建的堆内存不被其他东西所占用了（浏览器会在空闲的时候，查找每一个内存的引用状况，不被占用的都会给回收释放掉），则会释放
    ```
    + 栈内存释放
    ```javascript
    //打开浏览器形成的全局作用域是栈内存
    //手动执行函数形成的私有作用域是栈内存
    //基于es6中的let/const行程的块级作用域是栈内存
    /*
     全局作用域：关掉页面的时候才会销毁
     私有栈内存1.一般情况下，函数只要执行完，行程的私有栈内存就会被销毁释放掉（排除出现无限递归，无限死循环的模式）
     2. 但是一旦栈内存的某个东西（一般都是堆地址）被私有作用域以外的事务给占用了，则当前私有栈内存不能立即被销毁释放（特点，私有作用域中的私有变量等信息也保留下来了）
     * */
 
    ```
```javascript
var i=20
function fn() {
  i -=2
  return function(n) {
    console.log((++i)-n)
  }
}
var f=fn()
f(1)
f(2)
fn()(3)
fn()(4)
f(5)
console.log(i)
//18  18  16  14  14  19  
```

## 闭包的两个作用
  + 保护
  + 保存
```javascript
var a=9
function fn() {
  a=0
  return function (b){
   return b+a++
  }
}
var f=fn()
console.log(f(5))
console.log(fn()(5))
console.log(f(5))
console.log(a)
// 5  5  6  2
```
```javascript
function fn(i){
 return function (n){
  console.log(n+(i++))
 }
}
var f=fn(10)
f(20)
fn(20)(40)
fn(30)(50)
f(30)
//30  60  80  41
```

```javascript
var i=10
function fn(){
 return function (n){
  console.log(n+(++i))
 }
}
var f=fn()
f(20)
fn()(20)
fn()(30)
f(30)
```

## 闭包简述
函数执行形成一个私有作用域，保护里面的私有变量不受外界的干扰，这种保护机制称之为闭包

## 闭包作用
保存和保护

## 优缺点
1. 全局变量可能会造成命名冲突，使用闭包不用担心这个问题，因为它是私有化，加强了封装性，这样保护变量的安全
2. 每个模块都可以调用，当程序越来越复杂之后，会带不可预测的危险，所以推荐变量尽量私有化，当我们需要让局部变量发挥全局变量的作用时，可以考虑使用闭包
3. 于闭包是驻留在内存中，会增大内存使用量，使用不当很容易造成内存泄露，降低程序的性能，但是这并不是闭包本身的错误造成的

## 作用域链
JavaScript属于静态作用域，即声明的作用域是根据程序正问在编译时就确定的，有时也称为词法作用域。
其本质是JavaScript在执行过程中会创造可执行上下文，可执行上下文中的词法环境中含有外部词法环境的引用，我们可以通过这个引用获取外部词法环境的变量、声明等，这些引用串联起来一直指向全局的词法环境，因此形成了作用域链。