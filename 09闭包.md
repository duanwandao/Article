# 闭包作用域  
1. 创建函数  
	+ 开辟一个堆内存
	+ 把函数体中的代码当做字符串存储进去
	+ 把堆内存的地址赋值给函数名、变量名
	+ **函数在哪创建，那么它执行时候所需要查找的上级作用域就是谁**
2. 函数执行
	+ 形成一个全新的私有作用域、执行上下文、私有栈内存（执行一次形成一个，多个之间也不会产生影响）
	+ 形参赋值&变量提升
	+ 代码执行（把所属堆内存中的代码字符串拿出来一行一行的执行）
	+ **遇到一个变量，首先看他是不是私有变量（形参和在私有作用域中声明的变量是私有变量），是私有的就操作自己的变量即可，不是私有的则向上级作用域查找...一直找到全局作用域为止-->作用域链查找机制**
	+ 私有变量和外界的变量没有必然关系，可以理解为被栈内存保护起来了，这种机制其实就是闭包的保护机制
3. 关于堆栈内存释放问题
    > 函数执行就会形成栈内存（从内存中分配的一块空间）如果内存都不销毁释放，很容易就会导致栈内存溢出（内存爆满，电脑就会卡死），堆栈内存的释放问题是学习js的核心知识点
    + 堆内存释放问题
    ```javascript
    //创建一个引用类型值，就会产生一个堆内存
    //如果当前创建的堆内存不被其他东西所占用了（浏览器会在空闲的时候，查找每一个内存的引用状况，不被占用的都会给回收释放掉），则会释放
    ```
    + 栈内存释放
    ```javascript
    //打开浏览器形成的全局作用域是栈内存
    //手动执行函数形成的私有作用域是栈内存
    //基于es6中的let/const行程的块级作用域是栈内存
    /*
     全局作用域：关掉页面的时候才会销毁
     私有栈内存1.一般情况下，函数只要执行完，行程的私有栈内存就会被销毁释放掉（排除出现无限递归，无限死循环的模式）
     2. 但是一旦栈内存的某个东西（一般都是堆地址）被私有作用域以外的事务给占用了，则当前私有栈内存不能立即被销毁释放（特点，私有作用域中的私有变量等信息也保留下来了）
     * */
 
    ```
```javascript
var i=20
function fn() {
  i -=2
  return function(n) {
    console.log((++i)-n)
  }
}
var f=fn()
f(1)
f(2)
fn()(3)
fn()(4)
f(5)
console.log(i)
//18  18  16  14  14  19  
```

## 闭包的两个作用
  + 保护
  + 保存
```javascript
var a=9
function fn() {
  a=0
  return function (b){
   return b+a++
  }
}
var f=fn()
console.log(f(5))
console.log(fn()(5))
console.log(f(5))
console.log(a)
// 5  5  6  2
```
```javascript
function fn(i){
 return function (n){
  console.log(n+(i++))
 }
}
var f=fn(10)
f(20)
fn(20)(40)
fn(30)(50)
f(30)
//30  60  80  41
```
```javascript
var i=10
function fn(){
 return function (n){
  console.log(n+(++i))
 }
}
var f=fn()
f(20)
fn()(20)
fn()(30)
f(30)
```
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  